<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Prolog</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="Prolog"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-04-22 22:45:50 EDT"/>
<meta name="author" content="Joshua Eckroth"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="css/worg.css" type="text/css" media="screen" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>

<div id="preamble">
<a href="index.html">Home</a> &nbsp; &nbsp;
          <!-- Plupper Button -->
          <div id="plupperButton" style="display: inline;"></div>
          <!-- End of Plupper Button Code -->
          <!-- Plupper Tracking Code -->
          <script src="https://www.google.com/jsapi"></script>
          <script type="text/javascript"
                  src="https://static.plupper.com/js/plupper.js"></script>
          <script type="text/javascript">
            plupper.init("joshuaeckroth@plupper.com");
            plupper.enableCobrowsing();
          </script>
          <!-- End of Plupper Tracking Code -->

</div>

<div id="content">
<h1 class="title">Prolog</h1>

<p>Knowledge databases that you might build with <a href="./first-order-logic.html">first-order logic</a> suffer
from a fatal problem: the logic is so sophisticated that finding
answers efficiently (or even finding an answer at all) becomes
difficult or impossible. First-order logic is so powerful that it can
express almost anything, including very tricky or paradoxical
statements. It&rsquo;s not easy to design algorithms to work with such
systems.
</p>
<p>
Prolog is a programming language that allows us to &ldquo;program&rdquo; with
declarative knowledge. It puts limitations on the kinds of logical
statements we can write. These limitations are essential for allowing
Prolog programs to work efficiently and always provide an answer (or
determine there is no answer).
</p>
<p>
Because Prolog is a &ldquo;Turing-complete&rdquo; language, we can write any
program in Prolog. Of course, a program that is easy to write in Java
or C++ will, in all likelihood, be <i>very</i> difficult to write in
Prolog, although it is possible. Prolog programs often feel like
they&rsquo;re programs written in &ldquo;reverse,&rdquo; since they are written
declaratively rather than procedurally.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Some quick concepts and examples</a></li>
<li><a href="#sec-2">Defining complex predicates (rules)</a></li>
<li><a href="#sec-3">Negation as failure</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Some quick concepts and examples</h2>
<div class="outline-text-2" id="text-1">


<p>
There is probably no better way to introduce Prolog than to show some
examples. But first, a few important notes:
</p>
<ul>
<li>Prolog programs have two parts: a database (of facts and rules),
    and an interactive &ldquo;query&rdquo; tool; the database must be typed into a
    file.

</li>
<li>Prolog databases are &ldquo;consulted&rdquo; (loaded), and then the query tool
    is used to &ldquo;make queries&rdquo; (ask questions) about the database.

</li>
<li>How queries are answered is generally beyond the control of the
    programmer; Prolog uses a depth-first search to figure out how to
    answer queries; this is (generally) non-negotiable.

</li>
<li>&ldquo;Programs&rdquo; written in Prolog are &ldquo;executed&rdquo; by performing queries.
</li>
</ul>


<p>
Let&rsquo;s make a database by creating some facts:
</p>



<pre class="src src-prolog"><span style="color: #268bd2;">parent</span>(tom, liz).
<span style="color: #268bd2;">parent</span>(bob, ann).
<span style="color: #268bd2;">parent</span>(bob, pat).
<span style="color: #268bd2;">parent</span>(pat, jim).

<span style="color: #268bd2;">female</span>(pam).
<span style="color: #268bd2;">male</span>(tom).
<span style="color: #268bd2;">male</span>(bob).
<span style="color: #268bd2;">female</span>(liz).
<span style="color: #268bd2;">female</span>(pat).
<span style="color: #268bd2;">female</span>(ann).
<span style="color: #268bd2;">male</span>(jim).
</pre>


<p>
We type that into a file, maybe named <code>family.pl</code>, and &ldquo;consult&rdquo; the
file in the query tool.
</p>
<p>
Now what? Well, we can ask questions:
</p>



<pre class="src src-prolog">?- female(pam).
true.
</pre>


<p>
Ok, it&rsquo;s true that <code>pam</code> is a female.
</p>



<pre class="src src-prolog">?- parent(pat, ann).
false.
</pre>


<p>
Right, <code>pat</code> is not <code>ann</code>&rsquo;s parent.
</p>
<p>
Now let&rsquo;s use variables. Variables always start with capital
letters. Objects (like <code>pam</code>) must not.
</p>



<pre class="src src-prolog">?- parent(<span style="color: #268bd2;">X</span>, ann).
<span style="color: #268bd2;">X</span> = bob.
</pre>


<p>
So Prolog has found an assignment for <code>X</code> that makes the statement
true. We call <code>parent</code> a predicate (a 2-ary predicate because it
accepts two inputs), and we always write queries by first stating a
predicate.
</p>
<p>
Let&rsquo;s ask, &ldquo;Who are all the parents?&rdquo;
</p>



<pre class="src src-prolog">?- parent(<span style="color: #268bd2;">P</span>, <span style="color: #268bd2;">C</span>).
<span style="color: #268bd2;">P</span> = tom,
<span style="color: #268bd2;">C</span> = liz <span style="color: #859900;">;</span>
<span style="color: #268bd2;">P</span> = bob,
<span style="color: #268bd2;">C</span> = ann <span style="color: #859900;">;</span>
<span style="color: #268bd2;">P</span> = bob,
<span style="color: #268bd2;">C</span> = pat <span style="color: #859900;">;</span>
<span style="color: #268bd2;">P</span> = pat,
<span style="color: #268bd2;">C</span> = jim.
</pre>


<p>
(I typed the <code>;</code> &mdash; we type that to get the next answer.)
</p>
<p>
If I don&rsquo;t actually care who the children are, I can replace <code>C</code> with
<code>_</code> like so:
</p>



<pre class="src src-prolog">?- parent(<span style="color: #268bd2;">P</span>, <span style="color: #268bd2;">_</span>).
<span style="color: #268bd2;">P</span> = tom <span style="color: #859900;">;</span>
<span style="color: #268bd2;">P</span> = bob <span style="color: #859900;">;</span>
<span style="color: #268bd2;">P</span> = bob <span style="color: #859900;">;</span>
<span style="color: #268bd2;">P</span> = pat.
</pre>


<p>
We get <code>bob</code> twice because he&rsquo;s the parent of two people.
</p>
<p>
Now let&rsquo;s ask, &ldquo;Who are the female parents?&rdquo;
</p>



<pre class="src src-prolog">?- parent(<span style="color: #268bd2;">P</span>, <span style="color: #268bd2;">_</span>), female(<span style="color: #268bd2;">P</span>).
<span style="color: #268bd2;">P</span> = pat.
</pre>


<p>
The comma means &ldquo;AND.&rdquo; So the query requires that <code>P</code> is a parent and
a female.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Defining complex predicates (rules)</h2>
<div class="outline-text-2" id="text-2">


<p>
The predicates shown above (<code>parent</code>, <code>male</code>, and <code>female</code>) are always
true. They are called &ldquo;facts.&rdquo;
</p>
<p>
A &ldquo;rule,&rdquo; instead, is true only when some conditions are met. These
conditions look like the last query above: they typically require
several predicates to be true. The last query above is basically what
defines a &ldquo;mother.&rdquo; Let&rsquo;s make a rule (in our database file,
<code>family.pl</code>):
</p>



<pre class="src src-prolog"><span style="color: #268bd2;">mother</span>(<span style="color: #268bd2;">X</span>) :- parent(<span style="color: #268bd2;">X</span>, <span style="color: #268bd2;">_</span>), female(<span style="color: #268bd2;">X</span>).
</pre>


<p>
&ldquo;Consult&rdquo; the database again, and run these queries:
</p>



<pre class="src src-prolog">?- mother(pat).
true.

?- mother(jim).
false.

?- mother(<span style="color: #268bd2;">X</span>).
<span style="color: #268bd2;">X</span> = pat.
</pre>


<p>
Now for fathers. In the database, we add:
</p>



<pre class="src src-prolog"><span style="color: #268bd2;">father</span>(<span style="color: #268bd2;">X</span>) :- parent(<span style="color: #268bd2;">X</span>, <span style="color: #268bd2;">_</span>), male(<span style="color: #268bd2;">X</span>).
</pre>


<p>
And here is a query:
</p>



<pre class="src src-prolog">?- father(<span style="color: #268bd2;">X</span>).
<span style="color: #268bd2;">X</span> = tom <span style="color: #859900;">;</span>
<span style="color: #268bd2;">X</span> = bob <span style="color: #859900;">;</span>
<span style="color: #268bd2;">X</span> = bob <span style="color: #859900;">;</span>
false.
</pre>


<p>
Why the <code>false</code> at the end? The <code>;</code> basically means &ldquo;throw away the
answer you just gave, and try again.&rdquo; Prolog finds a parent <code>X</code>
(probably <code>pat</code>), but then that <code>X</code> does not satisfy the second part
of the <code>father</code> rule, which is written <code>male(X)</code>, so the answer is
<code>false</code> for that <code>X</code>.
</p>
<p>
Notice that <code>pat</code> is the parent of <code>jim</code> and <code>bob</code> is the parent of
<code>pat</code>. That makes <code>bob</code> a grandparent. Let&rsquo;s write a query to that
effect:
</p>



<pre class="src src-prolog">?- parent(<span style="color: #268bd2;">X</span>, <span style="color: #268bd2;">Y</span>), parent(<span style="color: #268bd2;">Y</span>, <span style="color: #268bd2;">_</span>).
<span style="color: #268bd2;">X</span> = bob,
<span style="color: #268bd2;">Y</span> = pat.
</pre>


<p>
See? <code>bob</code> is a grandparent. Let&rsquo;s make a rule:
</p>



<pre class="src src-prolog"><span style="color: #268bd2;">grandparent</span>(<span style="color: #268bd2;">X</span>) :- parent(<span style="color: #268bd2;">X</span>, <span style="color: #268bd2;">Y</span>), parent(<span style="color: #268bd2;">Y</span>, <span style="color: #268bd2;">_</span>).
</pre>


<p>
And here are two queries:
</p>



<pre class="src src-prolog">?- grandparent(bob).
true.

?- grandparent(jim).
false.
</pre>


<p>
These rules are essentially the following logical statements:
</p>


$$(\forall x)(\exists y)((Parent(x, y) \wedge Female(x)) \rightarrow
Mother(x))$$

$$(\forall x)(\exists y)((Parent(x, y) \wedge Male(x)) \rightarrow
Father(x))$$

$$(\forall x)(\exists y)(\exists z)((Parent(x, y) \wedge Parent(y, z))
\rightarrow Grandparent(x))$$

<p>
Notice how they all have the same form. Essentially, the variables in
the rule (<code>X</code> in each of these cases) have a \(\forall\) in front
(because the rule is true for all variables <code>X</code>, should certain
conditions hold), and the variables inside the rule (<code>Y</code> and <code>Z</code>) have
\(\exists\) in front because you only need to find one value for each
variable to make the rule true for some <code>X</code>. Notice we have
\(\rightarrow\) not \(\leftrightarrow\) because there may be more than one
way to satisfy a rule. For example,
</p>



<pre class="src src-prolog"><span style="color: #268bd2;">engineer</span>(<span style="color: #268bd2;">X</span>) :- mechanical_engineer(<span style="color: #268bd2;">X</span>).

<span style="color: #268bd2;">engineer</span>(<span style="color: #268bd2;">X</span>) :- chemical_engineer(<span style="color: #268bd2;">X</span>).

<span style="color: #268bd2;">engineer</span>(<span style="color: #268bd2;">X</span>) :- electrical_engineer(<span style="color: #268bd2;">X</span>).

<span style="color: #93a1a1; font-style: italic;">% </span><span style="color: #93a1a1; font-style: italic;">etc. etc.</span>
</pre>


<p>
This is how we do &ldquo;or&rdquo; in Prolog: we make new rules. In each rule, we
use commas for &ldquo;and,&rdquo; but (generally) do not write &ldquo;or&rdquo; inside a rule.
</p>


</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Negation as failure</h2>
<div class="outline-text-2" id="text-3">


<p>
Negation is a little bit funny in Prolog. That&rsquo;s because negation is a
little bit funny in life. How does anyone prove a negative statement?
&ldquo;I never read that book&rdquo; &mdash; how can that be proved?
</p>
<p>
Let&rsquo;s say we want a predicate like &ldquo;this person is not a father.&rdquo;
Well, we know how to figure out who <i>is</i> a father: we have the
<code>father</code> rule. How can we define a &ldquo;is not a father&rdquo; rule?
</p>
<p>
The first thing to note is Prolog does not allow us to use negatives
in facts. We cannot write &ldquo;not-a-father(jim).&rdquo; or anything like
that.
</p>
<p>
Instead, to prove a negative in Prolog, we use a little trick: we
assume everything stated in the database is <i>everything that exists</i>
(this is the &ldquo;closed-world assumption&rdquo;). Anything not stated in the
database does not exist. So, we can &ldquo;prove&rdquo; that <code>jim</code> is not a father
by <i>failing</i> to prove that <code>jim</code> is a father (with our <code>father</code> rule).
</p>



<pre class="src src-prolog"><span style="color: #268bd2;">not_a_father</span>(<span style="color: #268bd2;">X</span>) :- \+father(<span style="color: #268bd2;">X</span>).
</pre>


<p>
Some queries:
</p>



<pre class="src src-prolog">?- not_a_father(bob).
false.

?- not_a_father(jim).
true.
</pre>


<p>
The <code>\+</code> is the &ldquo;negation operator.&rdquo; The idea is that <code>\+father(X)</code> is
true whenever <code>father(X)</code> fails to be proved (recall that Prolog may
search <i>every possibility</i> in order to prove something; thus, negation
can be computationally expensive).
</p>
<p>
We cannot use <code>\+</code> on the left-side of a rule or written as a fact
because it makes no sense to say, &ldquo;this will fail to be proven
always.&rdquo; Only positive statements can be on the left of a rule or
written as a fact.
</p>
<p>
This connection between &ldquo;failing to prove&rdquo; and &ldquo;negation&rdquo; is called
&ldquo;negation as failure.&rdquo; Negation as failure means, &ldquo;proving the
negation of something is equivalent to failing to prove that
something&rdquo; and depends on a closed-world assumption.
</p>
<blockquote>

<p><b>negation-as-failure</b> <i>Also</i> <b>negation-by-failure</b> <i>n.</i> <i>Logic programming</i> <b>1</b> The reasonable assumption that <i>P</i> is false if one
has failed to prove that <i>P</i> is true. <b>2</b> The unreasonable assumption
that <i>P</i> is false if others have failed to prove that <i>P</i> is true. <b>3</b>
<i>Drugs</i> The ineffectiveness of the &ldquo;Just Say No!&rdquo; campaign. &mdash; <i>The computer contradictionary</i>
</p>
</blockquote>





<div style="font-size: 80%;">
<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">CSE 630 material</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://cse630.artifice.cc" property="cc:attributionName" rel="cc:attributionURL">Joshua Eckroth</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. Source code for this website available at <a href="https://github.com/joshuaeckroth/cse630-website">GitHub</a>.
</div>


</div>
</div>
</div>

</body>
</html>
